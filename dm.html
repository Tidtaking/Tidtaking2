<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Anbud – Postnummerkart med Heatmap, frekvens-søk og butikker</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body { height: 100%; margin: 0; padding: 0; }
  #map { width: 100%; height: 100vh; }
  #controls {
    position: absolute; top: 10px; right: 10px; z-index: 1000;
    background: white; padding: 10px; border-radius: 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    font-family: sans-serif; font-size: 14px; line-height: 1.4;
    width: 480px; max-height: 95vh; overflow-y: auto;
  }
  #controls label { display: flex; align-items: center; margin-bottom: 10px; padding: 4px; border-radius: 4px; }
  #controls label:nth-of-type(odd) { background-color: rgba(0,0,0,0.03); }
  #controls .label-content { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-left: 6px; }
  #controls .label-text { font-weight: 500; flex: 1; }
  #controls .counts { display: flex; flex-direction: column; align-items: flex-end; min-width: 120px; }
  #controls .counts .count { font-weight: bold; color: #0077cc; }
  #controls .counts .count + .count { margin-top: 4px; }
  #controls input[type='text'], #controls input[type='password'] { flex: 1; margin-right: 6px; padding: 4px; }
  #controls button { padding: 4px 8px; margin-left: 4px; }
  #search-summary { margin-top: 12px; font-size: 13px; }
  #search-summary table { width: 100%; border-collapse: collapse; margin-top: 4px; }
  #search-summary th, #search-summary td { border: 1px solid #ddd; padding: 6px; text-align: left; vertical-align: middle; }
  #search-summary th { background-color: #f4f4f4; font-weight: 600; }
  #search-summary tr:nth-child(odd) td { background-color: rgba(0,0,0,0.02); }
  .color-box { display: inline-block; width: 18px; height: 18px; border: 1px solid #999; border-radius: 3px; }
  #butikker-status, #butikker2-status { margin-top: 6px; font-size: 12px; color: #333; font-style: italic; }
</style>
</head>
<body>
<div id="controls">
  <label><input type="checkbox" id="toggleAnbud" checked />
    <div class="label-content">
      <span class="label-text">Anbudsgeografi - Frem til 1.7.2026</span>
      <div class="counts">
        <span id="postCountAnbud" class="count">0 postnumre</span>
        <span id="sumCountAnbud" class="count">0 antall</span>
      </div>
    </div>
  </label>
  <label><input type="checkbox" id="toggleBrukt" checked />
    <div class="label-content">
      <span class="label-text">Abonnenter brukt i dag - anbudsgeo</span>
      <div class="counts">
        <span id="postCountBrukt" class="count">0 postnumre</span>
        <span id="sumCountBrukt" class="count">0 antall</span>
      </div>
    </div>
  </label>
  <label><input type="checkbox" id="toggleInnenfor" checked />
    <div class="label-content">
      <span class="label-text">Innenfor anbud (maks utnyttelse)</span>
      <div class="counts">
        <span id="postCountInnenfor" class="count">0 postnumre</span>
        <span id="sumCountInnenfor" class="count">0 antall</span>
      </div>
    </div>
  </label>
  <label><input type="checkbox" id="toggleUtenfor" checked />
    <div class="label-content">
      <span class="label-text">Utenfor anbud</span>
      <div class="counts">
        <span id="postCountUtenfor" class="count">0 postnumre</span>
        <span id="sumCountUtenfor" class="count">0 antall</span>
      </div>
    </div>
  </label>

  <!-- Butikker -->
  <label><input type="checkbox" id="toggleButikk" checked />
    <div class="label-content">
      <span class="label-text">Butikker</span>
      <div class="counts">
        <span id="butikkCount" class="count"><span class="color-box" style="background:#0066cc"></span> 0 stk</span>
      </div>
    </div>
  </label>
  <!-- Butikker 2 -->
  <label><input type="checkbox" id="toggleButikk2" checked />
    <div class="label-content">
      <span class="label-text">Butikker 2</span>
      <div class="counts">
        <span id="butikk2Count" class="count"><span class="color-box" style="background:#00aa88"></span> 0 stk</span>
      </div>
    </div>
  </label>

  <div style="margin-top:8px; display:flex; align-items:center;">
    <input type="text" id="searchInput" placeholder="Søk postnummer (4 sifre), avis eller frekvensdag (1-7)" />
    <button id="searchBtn">Søk</button>
    <button id="exportBtn" disabled>Eksporter CSV</button>
  </div>
  <div style="margin-top:8px; display:flex; align-items:center;">
    <input type="password" id="passwordInput" placeholder="Skriv inn passord for navnesøk" />
    <button id="loginBtn">Aktiver navnesøk</button>
    <span id="loginStatus" style="margin-left:10px; font-weight:bold;"></span>
  </div>
  <div style="margin-top:8px; display:flex; align-items:center;">
    <button id="toggleHeatmapBtn" disabled>Vis heatmap</button>
  </div>
  <div id="search-summary"></div>
  <div id="search-timer" style="margin-top: 8px; font-size: 12px; font-style: italic;"></div>
  <div id="butikker-status"></div>
  <div id="butikker2-status"></div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
<script>
  // ----- INIT -----
  const searchBtn = document.getElementById('searchBtn');
  const exportBtn = document.getElementById('exportBtn');
  const heatmapBtn = document.getElementById('toggleHeatmapBtn');
  const butikkerStatus = document.getElementById('butikker-status');

  const map = L.map('map').setView([60,10],5);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution:'© OpenStreetMap contributors', maxZoom:18
  }).addTo(map);

  proj4.defs('EPSG:3035', '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs');
  function coords3035tilLatLng(c){
    const [x,y] = c;
    const [lon,lat] = proj4('EPSG:3035','WGS84',[x,y]);
    return L.latLng(lat,lon);
  }

  async function lesCSVRows(url){
    try {
      const res = await fetch(url);
      if(!res.ok) throw new Error(`${url}: HTTP ${res.status}`);
      const text = await res.text();
      return Papa.parse(text, {header:true, skipEmptyLines:true, delimiter: ','}).data;
    } catch(e) {
      console.warn('Kunne ikke lese', url, e);
      return [];
    }
  }

  async function lesAvisnavn(url) {
    try {
      const res = await fetch(url);
      if(!res.ok) throw new Error(`${url}: HTTP ${res.status}`);
      const text = await res.text();
      const data = Papa.parse(text, {header:true, skipEmptyLines:true}).data;
      const map = {};
      data.forEach(r => {
        if(r.ID && r.avis){
          const key = r.ID.trim().toLowerCase();
          map[key] = r.avis.trim();
        }
      });
      return map;
    } catch(e) {
      console.warn('Kunne ikke lese avisnavn', e);
      return {};
    }
  }

  // Støtter både: postnummer/postnr, antall, avis/avistittel, frekvens (135 eller 1,3,5)
  function group(rows, label = '') {
    const m = {};
    rows.forEach((r,i) => {
      const keyMap = {};
      Object.entries(r).forEach(([k,v])=>{
        const kk = (k||'').toString().trim().toLowerCase();
        keyMap[kk] = (typeof v === 'string') ? v.trim() : v;
      });

      const pRaw = keyMap['postnummer'] ?? keyMap['postnr'] ?? keyMap['pnr'] ?? '';
      const p = (pRaw ?? '').toString().padStart(4,'0');
      if(!/^\d{4}$/.test(p)) {
        console.warn(`[${label}] Rad ${i} har ugyldig postnummer`, r);
        return;
      }

      let num = 1;
      const antStr = keyMap['antall'] ?? keyMap['antal'] ?? keyMap['ant'] ?? keyMap['count'] ?? '';
      if(antStr !== '' && antStr != null){
        const n = Number(antStr.toString().replace(/\s/g,''));
        num = isNaN(n) ? 1 : n;
      }

      const avisRaw = keyMap['avis'] ?? keyMap['avistittel'] ?? keyMap['avisnavn'] ?? keyMap['avisid'] ?? '';
      const frekRaw = keyMap['frekvens'] ?? keyMap['frek'] ?? keyMap['freq'] ?? keyMap['dager'] ?? '';

      if(!m[p]) m[p] = {count:0, avis:new Map()};
      m[p].count += num;

      if(avisRaw || frekRaw){
        const avisKey = avisRaw ? avisRaw.toString().toLowerCase() : '(ukjent)';
        const prev = m[p].avis.get(avisKey) || {count:0, frekvenser:new Set()};
        prev.count += num;

        if(frekRaw){
          const s = frekRaw.toString().trim();
          if(s.includes(',')){
            s.split(',').forEach(x=>{
              const t=x.trim();
              if(/^[1-7]$/.test(t)) prev.frekvenser.add(t);
              else [...t].forEach(c=>/^[1-7]$/.test(c)&&prev.frekvenser.add(c));
            });
          } else {
            [...s].forEach(c=>/^[1-7]$/.test(c)&&prev.frekvenser.add(c));
          }
        }

        m[p].avis.set(avisKey, prev);
      }
    });
    return m;
  }

  let kanSokeNavn = false;
  const riktigPassord = "hemmelig123";

  let dC, dD, dInnenfor, dUtenfor;
  let fC, fD, fInnenfor, fUtenfor;
  let avisNavnMap;
  const layers = {};
  let searchLayer = null;
  let heatLayer = null;
  let showingHeatmap = false;
  let lastMatches = [];

  // Farger (Utenfor lik Innenfor)
  const filterColors = {
    Anbud: '#ff3333',
    Brukt: '#ffff00',
    Innenfor: '#663399',
  Utenfor: '#ff9800' // oransje
  };
  const butikkFarge = '#0066cc';
  const butikk2Farge = '#00aa88';

  const filterKeys = {
    Anbud: 'anbudet',
    Brukt: 'abo_bruktidag_anbud',
    Innenfor: 'Innenfor anbud',
    Utenfor: 'Utenfor anbud'
  };

  function enrich(arr,mapData){
    arr.forEach(f=>{
      const p = f.properties.postnummer.trim().padStart(4,'0');
      const info = mapData[p] || {count:0, avis:new Map()};
      f.properties.antall = info.count;
      f.properties.avisMap = info.avis;
      if(kanSokeNavn){
        f.properties.avis = Array.from(info.avis.entries())
                                .map(([avisId,ant]) => `${avisNavnMap?.[avisId] || avisId}: ${ant.count}`)
                                .join(', ');
      } else {
        f.properties.avis = Array.from(info.avis.entries())
                                .map(([avisId,ant]) => `${avisId}: ${ant.count}`)
                                .join(', ');
      }
    });
  }

  function enrichAll(){
    enrich(fC,dC);
    enrich(fD,dD);
    enrich(fInnenfor,dInnenfor);
    enrich(fUtenfor,dUtenfor);
    Object.values(layers).forEach(layer => layer.eachLayer(l=>{
      const p = l.feature?.properties || {};
      if(!p) return;
      if(l.setPopupContent){
        const alleFrek = new Set([].concat(...Array.from(p.avisMap?.values() || []).map(a => Array.from(a.frekvenser || []))));
        l.setPopupContent(`
  <strong>Postnummer: ${p.postnummer || ''}</strong><br>
  Totalt antall: ${p.antall || 0}<br>
  Detaljer pr avis: ${p.avis || 'Ingen'}<br>
  Frekvensdager: ${formatFrekvenser(alleFrek)}
`);
      }
    }));
  }

  function oppdaterFilterTellinger(){
    ['Anbud','Brukt','Innenfor','Utenfor'].forEach((k,i)=>{
      const mapData = [dC,dD,dInnenfor,dUtenfor][i];
      if(!mapData) return;
      const postnummerer = Object.keys(mapData); // unike postnumre fra CSV (via group())
      const antallSum = postnummerer.reduce((s,p) => s + (mapData[p]?.count || 0), 0);
      document.getElementById('postCount'+k).innerHTML = `<span class="color-box" style="background:${filterColors[k]}"></span> ${postnummerer.length.toLocaleString()} postnumre`;
      document.getElementById('sumCount'+k).innerHTML = `<span class="color-box" style="background:${filterColors[k]}"></span> ${antallSum.toLocaleString()} antall`;
    });
  }
  function oppdaterButikkTellere(){
    const n1 = layers.Butikk ? layers.Butikk.getLayers().length : 0;
    const n2 = layers.Butikk2 ? layers.Butikk2.getLayers().length : 0;
    const el1 = document.getElementById('butikkCount');
    if(el1) el1.innerHTML = `<span class="color-box" style="background:${butikkFarge}"></span> ${n1} stk`;
    const el2 = document.getElementById('butikk2Count');
    if(el2) el2.innerHTML = `<span class="color-box" style="background:${butikk2Farge}"></span> ${n2} stk`;
  }

  // Parsing av søk: postnummer (4 siffer), avis (tekst/id) og frekvensdager (1-7)
  function parseSearchInput(input) {
    const dagMap = { 'man':'1','tir':'2','ons':'3','tor':'4','fre':'5','lør':'6','lor':'6','søn':'7','son':'7' };
    const parts = input.toLowerCase().split(',').map(s => s.trim()).filter(Boolean);
    const frekvensSok = new Set();
    const avisSok = [];
    let postnummerSok = null;
    parts.forEach(p => {
      if (/^\d{4}$/.test(p)) postnummerSok = p;
      else if (/^[1-7]$/.test(p)) frekvensSok.add(p);
      else if (dagMap[p]) frekvensSok.add(dagMap[p]);
      else avisSok.push(p);
    });
    return {postnummerSok, avisSok, frekvensSok};
  }

  function avisMatcher(avisMap, avisSok, kanSokeNavn, avisNavnMap) {
    if(avisSok.length === 0) return true;
    if(!kanSokeNavn) {
      return avisSok.some(sokStr => Array.from(avisMap.keys()).some(avisId => avisId === sokStr));
    }
    return avisSok.some(sokStr => Array.from(avisMap.keys()).some(avisId => {
      const navn = avisNavnMap?.[avisId] ? avisNavnMap[avisId].toLowerCase() : avisId.toLowerCase();
      return avisId === sokStr || navn.includes(sokStr);
    }));
  }

  function frekvensMatcher(avisMap, frekvensSok) {
    if(frekvensSok.size === 0) return true;
    for(const avisData of avisMap.values()) {
      for(const f of (avisData.frekvenser || [])) {
        if(typeof f === 'string' && frekvensSok.has(f)) return true;
        if(typeof f === 'number' && frekvensSok.has(f.toString())) return true;
      }
    }
    return false;
  }

  function formatFrekvenser(frekvenserSet) {
    const dagMap = { '1':'Man','2':'Tir','3':'Ons','4':'Tor','5':'Fre','6':'Lør','7':'Søn' };
    const dager = Array.from(frekvenserSet).filter(c => dagMap[c]).sort((a,b) => a-b).map(c => dagMap[c]);
    return dager.join(', ');
  }

  // Lasting av data – Brukt: forsøk detaljert fil først
  Promise.all([
    lesCSVRows('anbud_postnummer.csv'),     // cRows (Anbud)
    lesCSVRows('abo_bruktidag_anbud.csv'),  // dRowsBasic (fallback)
    lesCSVRows('post_abo_idag.csv'),        // dRowsDetalj (NY)
    lesCSVRows('innenforanbud.csv'),        // eRows
    lesCSVRows('utenforanbud.csv'),         // fRows
    lesAvisnavn('avisid.csv'),
    fetch('postnummer_part01.geojson').then(r=>r.json()),
    fetch('postnummer_part02.geojson').then(r=>r.json()),
    fetch('postnummer_part03.geojson').then(r=>r.json()),
    fetch('filtrert_anbud.geojson').then(r=>r.json())
  ]).then(([cRows,dRowsBasic,dRowsDetalj,eRows,fRows, avisMap, g1,g2,g3,geoAnb])=>{
    dC = group(cRows, 'Anbud');

    const dD_detalj = group(dRowsDetalj, 'Brukt_detalj');
    const dD_basic  = group(dRowsBasic,  'Brukt_basic');
    dD = Object.keys(dD_detalj).length ? dD_detalj : dD_basic;

    dInnenfor = group(eRows, 'Innenfor');
    dUtenfor  = group(fRows, 'Utenfor');
    avisNavnMap = avisMap;

    const nC = Object.keys(dC).map(p => p.padStart(4,'0'));
    const nD = Object.keys(dD).map(p => p.padStart(4,'0'));
    const nInnenfor = Object.keys(dInnenfor).map(p => p.padStart(4,'0'));
    const nUtenfor  = Object.keys(dUtenfor).map(p => p.padStart(4,'0'));

    const base = [...g1.features,...g2.features,...g3.features];
    const geoBase = {type:'FeatureCollection',features:base};

    fC = geoAnb.features.filter(f=>nC.includes(f.properties.postnummer.trim().padStart(4,'0')));
    fD = geoAnb.features.filter(f=>nD.includes(f.properties.postnummer.trim().padStart(4,'0')));
    fInnenfor = geoAnb.features.filter(f=>nInnenfor.includes(f.properties.postnummer.trim().padStart(4,'0')));
    fUtenfor  = geoBase.features.filter(f=>nUtenfor.includes(f.properties.postnummer.trim().padStart(4,'0')));

    enrichAll();
    oppdaterFilterTellinger();

    layers.Anbud    = L.geoJSON(fC,{coordsToLatLng:coords3035tilLatLng,style:()=>({color:filterColors.Anbud,fillOpacity:0.5,weight:1})});
    layers.Brukt    = L.geoJSON(fD,{coordsToLatLng:coords3035tilLatLng,style:()=>({color:filterColors.Brukt,fillOpacity:0.5,weight:1})});
    layers.Innenfor = L.geoJSON(fInnenfor,{coordsToLatLng:coords3035tilLatLng,style:()=>({color:filterColors.Innenfor,fillOpacity:0.5,weight:1})});
    layers.Utenfor  = L.geoJSON(fUtenfor,{coordsToLatLng:coords3035tilLatLng,style:()=>({color:filterColors.Utenfor,fillOpacity:0.5,weight:1})});

    Object.values(layers).forEach(layer => layer.eachLayer(l=>{
      const p = l.feature.properties;
      l.bindPopup(`
        <strong>Postnummer: ${p.postnummer}</strong><br>
        Totalt antall: ${p.antall}<br>
        Detaljer pr avis: ${p.avis || 'Ingen'}
      `);
    }));

    function oppdaterLag(){
      Object.entries(layers).forEach(([k,lyr])=>{
        const cb = document.getElementById('toggle'+k);
        if(!cb) return;
        cb.checked ? map.addLayer(lyr) : map.removeLayer(lyr);
      });
      const vis = Object.values(layers).flatMap(l=>map.hasLayer(l)?(l.getLayers?l.getLayers():[]):[]);
      if(vis.length) map.fitBounds(L.featureGroup(vis).getBounds().pad(0.05));
    }
    ;['Anbud','Brukt','Innenfor','Utenfor','Butikk','Butikk2'].forEach(k=>
      document.getElementById('toggle'+k)?.addEventListener('change',oppdaterLag)
    );
    oppdaterLag();

    searchBtn.addEventListener('click', searchMap);
    document.getElementById('searchInput').addEventListener('keyup', e=>e.key==='Enter' && searchMap());

    exportBtn.addEventListener('click', () => {
      if(!lastMatches.length) return;
      const csv = Papa.unparse(lastMatches);
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'sokeresultater.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Butikk-lag
    initButikker();
    initButikker2();
  });

  function getPolygonCentroid(feature){
    const geom = feature.geometry;
    if(geom.type === 'Polygon'){
      const coords = geom.coordinates[0];
      let latSum = 0, lngSum = 0;
      coords.forEach(([x,y])=>{
        const [lon, lat] = proj4('EPSG:3035','WGS84',[x,y]);
        latSum += lat;
        lngSum += lon;
      });
      const len = coords.length;
      return [latSum/len, lngSum/len];
    }
    return [0,0];
  }

  function searchMap() {
    const startTime = performance.now();
    const qRawInput = document.getElementById('searchInput').value.trim();
    if (!qRawInput) return;

    // Eksakt "N dag frekvens"
    const dagFreqMatch = qRawInput.match(/^(\d) dag frekvens$/i);
    if (dagFreqMatch) {
      const ønsketDager = Number(dagFreqMatch[1]);
      searchExactDayFrequency(ønsketDager);
      return;
    }

    // Nullstill lag/heatmap
    Object.values(layers).forEach(l => map.removeLayer(l));
    if (searchLayer) { map.removeLayer(searchLayer); searchLayer = null; }
    if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; showingHeatmap = false; heatmapBtn.innerText = 'Vis heatmap'; heatmapBtn.disabled = true; }

    const { postnummerSok, avisSok, frekvensSok } = parseSearchInput(qRawInput);
    const matchedPostnr = new Set();

    // Finn postnummer som matcher input
    Object.entries({ Anbud: dC, Brukt: dD, Innenfor: dInnenfor, Utenfor: dUtenfor }).forEach(([_, mapData]) => {
      Object.entries(mapData).forEach(([pRaw, info]) => {
        const p = pRaw.padStart(4, '0');
        if (postnummerSok) {
          if (p === postnummerSok) matchedPostnr.add(p);
        } else {
          const avisMatch = avisMatcher(info.avis, avisSok, kanSokeNavn, avisNavnMap);
          const frekMatch = frekvensMatcher(info.avis, frekvensSok);
          if (avisMatch && frekMatch) matchedPostnr.add(p);
        }
      });
    });

    const allFeatures = [...fC, ...fD, ...fInnenfor, ...fUtenfor];
    const matches = allFeatures.filter(f => matchedPostnr.has(f.properties.postnummer.trim().padStart(4, '0')));

    if (!matches.length) {
      document.getElementById('search-summary').innerHTML = '';
      exportBtn.disabled = true;
      heatmapBtn.disabled = true;
      alert(`Ingen treff for "${qRawInput}"`);
      document.getElementById('search-timer').innerText = '';
      return;
    }

    // -------------------------
    // Oppsummeringstabell
    // -------------------------
    let totalSum = 0; // KUN Innenfor + Utenfor
    let samletFrekvenserTotal = new Set(); // speiler bare det som inngår i totalen
    let samletAviserTotal = new Set();     // UNIKE aviser – kun Innenfor/Utenfor

    let html = '<table><thead><tr><th>Filter</th><th>Farge</th><th>Postnumre</th><th>Antall for søk (unik)</th><th>Frekvensdager</th></tr></thead><tbody>';

    Object.entries({ Anbud: dC, Brukt: dD, Innenfor: dInnenfor, Utenfor: dUtenfor }).forEach(([filterKey, mapData]) => {
      const keys = Object.keys(mapData).filter(p => matchedPostnr.has(p));
      let sumCount = 0;
      let sumAlleDager = 0;
      let samletFrekvenser = new Set();

      keys.forEach(p => {
        const entry = mapData[p];
        if (!entry) return;

        const avisMap = entry.avis || new Map();

        // Har avis/frekvens-detaljer (som Innenfor/Utenfor eller Brukt detalj): bruk direkte
        if (avisMap.size > 0) {
          for (const [avisId, avisData] of avisMap.entries()) {
            const navn = avisNavnMap?.[avisId] || avisId;

            const avisMatch = (avisSok.length === 0) ||
              avisSok.some(sokStr => (avisId === sokStr) || navn.toLowerCase().includes(sokStr));
            if (!avisMatch) continue;

            let matchedDaysCount = 0;
            if (frekvensSok.size === 0) {
              matchedDaysCount = Math.max(avisData.frekvenser?.size || 0, 1);
              avisData.frekvenser.forEach(f => {
                const fs = f.toString();
                samletFrekvenser.add(fs);
                if (filterKey === 'Innenfor' || filterKey === 'Utenfor') samletFrekvenserTotal.add(fs);
              });
            } else {
              avisData.frekvenser.forEach(f => {
                const fs = f.toString();
                if (frekvensSok.has(fs)) {
                  matchedDaysCount += 1;
                  samletFrekvenser.add(fs);
                  if (filterKey === 'Innenfor' || filterKey === 'Utenfor') samletFrekvenserTotal.add(fs);
                }
              });
            }

            // Duplikater-raden
            sumAlleDager += avisData.count * matchedDaysCount;

            // Unik sum og UNIKE AVISER (kun Innenfor/Utenfor)
            if (matchedDaysCount > 0) {
              sumCount += avisData.count;
              if (filterKey === 'Innenfor' || filterKey === 'Utenfor') {
                samletAviserTotal.add(navn);
              }
            }
          }
          return; // ferdig med dette postnr
        }

        // Dataset UTEN dagsoppløsning (typisk Anbud eller Brukt-basic)
        const c = Number(entry.count) || 0;
        sumCount += c; // unik sum = postnummer-nivå count

        // Bruk referanse-dager fra Innenfor/Utenfor for å beregne duplikater likt
        let refAvisMap = new Map();
        if (filterKey === 'Anbud' || filterKey === 'Brukt' || filterKey === 'Innenfor') {
          refAvisMap = (dInnenfor[p]?.avis) || new Map();
        } else if (filterKey === 'Utenfor') {
          refAvisMap = (dUtenfor[p]?.avis) || new Map();
        }

        let dupForP = 0;
        refAvisMap.forEach((avisData) => {
          if (frekvensSok.size === 0) {
            const mult = Math.max(avisData.frekvenser?.size || 0, 1);
            dupForP += avisData.count * mult;
            avisData.frekvenser.forEach(f => {
              const fs = f.toString();
              samletFrekvenser.add(fs);
              if (filterKey === 'Innenfor' || filterKey === 'Utenfor') samletFrekvenserTotal.add(fs);
            });
          } else {
            let m = 0;
            avisData.frekvenser.forEach(f => {
              const fs = f.toString();
              if (frekvensSok.has(fs)) {
                m += 1;
                samletFrekvenser.add(fs);
                if (filterKey === 'Innenfor' || filterKey === 'Utenfor') samletFrekvenserTotal.add(fs);
              }
            });
            dupForP += avisData.count * m;
          }
        });
        sumAlleDager += dupForP;
      });

      // Totalen skal kun være Innenfor + Utenfor
      if (filterKey === 'Innenfor' || filterKey === 'Utenfor') totalSum += sumCount;

      const color = filterColors[filterKey] || '#000';
      html += `<tr>
        <td>${filterKeys[filterKey]}</td>
        <td><span class="color-box" style="background:${color};"></span></td>
        <td>${keys.length.toLocaleString()}</td>
        <td>${sumCount.toLocaleString()}</td>
        <td>${formatFrekvenser(samletFrekvenser)}</td>
      </tr>`;

      html += `<tr style="font-size: 12px; color: #444;">
        <td colspan="3" style="text-align:right; font-style: italic;">Sum alle dager (duplikater):</td>
        <td>${sumAlleDager.toLocaleString()}</td>
        <td></td>
      </tr>`;
    });

    html += `<tr style="font-weight:bold; background:#eef;">
      <td colspan="3">Totalt abonnenter (ekskl. Anbud & Brukt)</td>
      <td>${totalSum.toLocaleString()}</td>
      <td>${formatFrekvenser(samletFrekvenserTotal)}</td>
    </tr>`;

    if (samletAviserTotal.size > 0) {
      html += `<tr style="font-style: italic; font-size: 12px; background:#f9f9f9;">
        <td colspan="5">Antall aviser som matcher søket: ${samletAviserTotal.size}. Aviser: ${Array.from(samletAviserTotal).sort().join(', ')}</td>
      </tr>`;
    }

    html += '</tbody></table>';
    document.getElementById('search-summary').innerHTML = html;

    // -------------------------
    // CSV-data
    // -------------------------
    lastMatches = [];
    matches.forEach(f => {
      const p = f.properties.postnummer.trim().padStart(4, '0');
      const antallTotal = f.properties.antall;

      ['Anbud', 'Brukt', 'Innenfor', 'Utenfor'].forEach(filt => {
        const mapData = { Anbud: dC, Brukt: dD, Innenfor: dInnenfor, Utenfor: dUtenfor }[filt] || {};
        if (!mapData[p]) return;
        const filterNavn = filterKeys[filt] || '';
        const avisMap = mapData[p]?.avis || new Map();

        if (avisMap.size === 0) {
          const entry = mapData[p];
          const c = Number(entry?.count) || 0;
          lastMatches.push({ filter: filterNavn, postnummer: p, antall_total: antallTotal, avis: '(ukjent/ikke spesifisert)', antall_avis: c });
        } else {
          avisMap.forEach((avisData, avisId) => {
            const renAvisId = avisId.trim().toLowerCase();
            const navn = avisNavnMap?.[renAvisId] || avisId;
            lastMatches.push({ filter: filterNavn, postnummer: p, antall_total: antallTotal, avis: navn, antall_avis: avisData.count });
          });
        }
      });
    });

    exportBtn.disabled = false;

    // -------------------------
    // Heatmap
    // -------------------------
    const intensitetFaktor = 5;
    const heatPointsRaw = matches.map(f => {
      const [lat, lng] = getPolygonCentroid(f);
      return [lat, lng, (f.properties.antall || 1) * intensitetFaktor];
    });
    const maxAntall = Math.max(...heatPointsRaw.map(p => p[2]));
    const heatPoints = heatPointsRaw.map(p => [p[0], p[1], p[2] / maxAntall]);

    heatmapBtn.disabled = false;
    showingHeatmap = false;
    heatmapBtn.innerText = 'Vis heatmap';

    heatmapBtn.onclick = () => {
      if (showingHeatmap) {
        if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }
        if (searchLayer) { map.addLayer(searchLayer); }
        heatmapBtn.innerText = 'Vis heatmap';
        showingHeatmap = false;
      } else {
        if (searchLayer) { map.removeLayer(searchLayer); }
        heatLayer = L.heatLayer(heatPoints, { radius: 15, blur: 10, maxZoom: 17, gradient: {
          0.0: 'rgba(255,0,0,1.0)', 0.2: 'rgba(255,0,0,0.8)', 0.4: 'rgba(255,0,0,0.6)', 0.6: 'rgba(255,0,0,0.4)', 1.0: 'rgba(255,0,0,0.2)'
        }}).addTo(map);
        heatmapBtn.innerText = 'Vis polygon';
        showingHeatmap = true;
      }
    };

    // -------------------------
    // Treff som polygon
    // -------------------------
    searchLayer = L.geoJSON(matches, { coordsToLatLng: coords3035tilLatLng, style: () => ({ color: '#555', fillOpacity: 0.3, weight: 2 }) }).addTo(map);
    searchLayer.eachLayer(l => {
      const p = l.feature.properties;
      l.bindPopup(`
        <strong>Postnummer: ${p.postnummer}</strong><br>
        Totalt antall: ${p.antall}<br>
        Detaljer pr avis: ${p.avis || 'Ingen'}
      `);
      l.openPopup();
    });

    map.fitBounds(searchLayer.getBounds().pad(0.05));

    const endTime = performance.now();
    const elapsed = endTime - startTime;
    document.getElementById('search-timer').innerText = `Søket brukte ${(elapsed / 1000).toFixed(2)} sekunder`;
  }

  // Eksakt «N dag frekvens»-søk (Innenfor/Utenfor)
  function searchExactDayFrequency(antallDager) {
    const startTime = performance.now();

    const allFeatures = [...fInnenfor, ...fUtenfor];
    const matchedPostnr = new Set();

    allFeatures.forEach(f => {
      const p = f.properties.postnummer.trim().padStart(4, '0');
      const innenforData = dInnenfor[p];
      const utenforData = dUtenfor[p];
      const avisMap = innenforData?.avis || utenforData?.avis || new Map();
      for (const avisData of avisMap.values()) {
        if (avisData.frekvenser.size === antallDager) { matchedPostnr.add(p); break; }
      }
    });

    if (matchedPostnr.size === 0) {
      document.getElementById('search-summary').innerHTML = '';
      exportBtn.disabled = true;
      heatmapBtn.disabled = true;
      alert(`Ingen treff for "${antallDager} dag frekvens"`);
      document.getElementById('search-timer').innerText = '';
      return;
    }

    const dagMap = { '1': 'Man', '2': 'Tir', '3': 'Ons', '4': 'Tor', '5': 'Fre', '6': 'Lør', '7': 'Søn' };
    const dagRekkefølge = ['Man','Tir','Ons','Tor','Fre','Lør','Søn'];

    const aggregert = {};
    matchedPostnr.forEach(p => {
      ['Innenfor', 'Utenfor'].forEach(filt => {
        const mapData = { Innenfor: dInnenfor, Utenfor: dUtenfor }[filt] || {};
        if (!mapData[p]) return;
        const avisMap = mapData[p]?.avis || new Map();
        avisMap.forEach((avisData, avisId) => {
          if (avisData.frekvenser.size === antallDager) {
            const renAvisId = avisId.trim().toLowerCase();
            const navn = avisNavnMap?.[renAvisId] || avisId;
            const frekvensDager = Array.from(avisData.frekvenser).map(f => dagMap[f.toString()] || f.toString());
            frekvensDager.sort((a,b)=>dagRekkefølge.indexOf(a)-dagRekkefølge.indexOf(b));
            const frekvensTekst = frekvensDager.join(', ');
            if (!aggregert[navn]) aggregert[navn] = {};
            if (!aggregert[navn][filt]) aggregert[navn][filt] = { sum: 0, frekvens: frekvensTekst };
            aggregert[navn][filt].sum += avisData.count;
          }
        });
      });
    });

    let totalPerFilter = { Innenfor: 0, Utenfor: 0 };
    let samletAviser = Object.keys(aggregert).sort();

    let html = `<table>
      <thead><tr><th>Avis</th><th>Innenfor</th><th>Utenfor</th><th>Totalt</th><th>Frekvensdager</th></tr></thead><tbody>`;

    lastMatches = [];
    samletAviser.forEach(avis => {
      const innenforData = aggregert[avis].Innenfor || { sum: 0, frekvens: '' };
      const utenforData = aggregert[avis].Utenfor || { sum: 0, frekvens: '' };
      const innenforSum = innenforData.sum || 0;
      const utenforSum = utenforData.sum || 0;
      const sum = innenforSum + utenforSum;
      totalPerFilter.Innenfor += innenforSum;
      totalPerFilter.Utenfor += utenforSum;
      const frekvensTekst = innenforData.frekvens || utenforData.frekvens || '';
      html += `<tr><td>${avis}</td><td>${innenforSum ? innenforSum.toLocaleString() : ''}</td><td>${utenforSum ? utenforSum.toLocaleString() : ''}</td><td>${sum.toLocaleString()}</td><td>${frekvensTekst}</td></tr>`;
      if (innenforSum) lastMatches.push({ filter: 'Innenfor', postnummer: '', antall_total: innenforSum, avis, antall_avis: innenforSum, frekvens: frekvensTekst });
      if (utenforSum) lastMatches.push({ filter: 'Utenfor', postnummer: '', antall_total: utenforSum, avis, antall_avis: utenforSum, frekvens: frekvensTekst });
    });

    const grandTotal = totalPerFilter.Innenfor + totalPerFilter.Utenfor;
    html += `<tr style="font-weight:bold; background:#eef;"><td>Totalt abonnenter</td><td>${totalPerFilter.Innenfor.toLocaleString()}</td><td>${totalPerFilter.Utenfor.toLocaleString()}</td><td>${grandTotal.toLocaleString()}</td><td></td></tr>`;
    html += `</tbody></table>`;
    html += `<p style="font-style: italic; font-size: 12px; margin-top: 8px;"><strong>Antall aviser som matcher søket: ${samletAviser.length}.</strong> Aviser: ${samletAviser.join(', ')}</p>`;

    document.getElementById('search-summary').innerHTML = html;
    exportBtn.disabled = false; heatmapBtn.disabled = false;

    // Vis polygoner i dette moduset
    const matches = [...fInnenfor, ...fUtenfor].filter(f => matchedPostnr.has(f.properties.postnummer.trim().padStart(4, '0')));
    if (searchLayer) { map.removeLayer(searchLayer); searchLayer = null; }
    if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; showingHeatmap = false; heatmapBtn.innerText = 'Vis heatmap'; }

    const layer = L.geoJSON(matches, { coordsToLatLng: coords3035tilLatLng, style: () => ({ color: '#0077cc', fillOpacity: 0.4, weight: 2 }) });
    searchLayer = layer.addTo(map);
    searchLayer.eachLayer(l => {
      const p = l.feature.properties;
      l.bindPopup(`<strong>Postnummer: ${p.postnummer}</strong><br>Totalt antall: ${p.antall}<br>Detaljer pr avis: ${p.avis || 'Ingen'}`);
    });
    map.fitBounds(searchLayer.getBounds().pad(0.05));

    const endTime = performance.now();
    const elapsed = endTime - startTime;
    document.getElementById('search-timer').innerText = `Søket brukte ${(elapsed / 1000).toFixed(2)} sekunder`;
  }

  // === Butikker: les CSV, bruk lat/lon eller x3035/y3035, ellers geokodér adresse ===
  async function initButikker(){
    try {
      const rows = await lesCSVRows('butikker.csv');
      if(!rows.length){ if(butikkerStatus) butikkerStatus.textContent = ''; return; }

      const butikkLayer = L.layerGroup();
      layers.Butikk = butikkLayer;

      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      async function geocodeAdresse(q){
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&addressdetails=0&countrycodes=no&q=${encodeURIComponent(q)}`;
        const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if(!res.ok) return null;
        const data = await res.json();
        if(Array.isArray(data) && data[0]) return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
        return null;
      }

      const points = [];
      let toGeocode = 0, doneGeocode = 0;

      for(const r of rows){
        const navn = r.navn || r.name || '';
        const adr  = r.adresse || r.address || '';
        const pn   = (r.postnummer || r.postnr || '').toString().padStart(4,'0');
        const ps   = r.poststed || r.sted || '';

        let lat = parseFloat(r.lat || r.latitude);
        let lon = parseFloat(r.lon || r.lng || r.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) { points.push({lat, lon, navn, adr, pn, ps}); continue; }

        const x = parseFloat(r.x3035 || r.x);
        const y = parseFloat(r.y3035 || r.y);
        if (Number.isFinite(x) && Number.isFinite(y)) {
          const [lonW, latW] = proj4('EPSG:3035','WGS84',[x,y]);
          points.push({lat: latW, lon: lonW, navn, adr, pn, ps});
          continue;
        }

        toGeocode++;
        points.push({lat: null, lon: null, navn, adr, pn, ps});
      }

      if(toGeocode){
        if(butikkerStatus) butikkerStatus.textContent = `Geokoder ${toGeocode} adresser …`;
        for(const p of points){
          if(p.lat != null && p.lon != null) continue;
          const query = [p.adr, p.pn, p.ps, 'Norge'].filter(Boolean).join(', ');
          const res = await geocodeAdresse(query);
          if(res){ p.lat = res.lat; p.lon = res.lon; }
          doneGeocode++;
          if(butikkerStatus && doneGeocode % 1 === 0){ butikkerStatus.textContent = `Geokoder ${doneGeocode}/${toGeocode} …`; }
          await sleep(300);
        }
        if(butikkerStatus) butikkerStatus.textContent = '';
      }

      let added = 0;
      points.forEach(p => {
        if(!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return;
        const m = L.circleMarker([p.lat, p.lon], {radius: 6, weight: 1, color: butikkFarge, fillOpacity: 0.85});
        const adrTxt = [p.adr, p.pn, p.ps].filter(Boolean).join(', ');
        m.bindPopup(`<strong>${p.navn || 'Butikk'}</strong><br>${adrTxt}`);
        butikkLayer.addLayer(m);
        added++;
      });

      const cb = document.getElementById('toggleButikk');
      if(cb?.checked) map.addLayer(butikkLayer);
      oppdaterButikkTellere();
      if(added){ try { map.fitBounds(butikkLayer.getBounds().pad(0.05)); } catch {} }

    } catch(err){
      console.warn('Feil ved lasting av butikker:', err);
      if(butikkerStatus) butikkerStatus.textContent = '';
    }
  }

  // === Butikker 2 ===
  async function initButikker2(){
    try {
      const rows = await lesCSVRows('butikker2.csv');
      const butikker2Status = document.getElementById('butikker2-status');
      if(!rows.length){ if(butikker2Status) butikker2Status.textContent = ''; return; }

      const butikkLayer = L.layerGroup();
      layers.Butikk2 = butikkLayer;

      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      async function geocodeAdresse(q){
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&addressdetails=0&countrycodes=no&q=${encodeURIComponent(q)}`;
        const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if(!res.ok) return null;
        const data = await res.json();
        if(Array.isArray(data) && data[0]) return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
        return null;
      }

      const points = [];
      let toGeocode = 0, doneGeocode = 0;

      for(const r of rows){
        const navn = r.navn || r.name || '';
        const adr  = r.adresse || r.address || '';
        const pn   = (r.postnummer || r.postnr || '').toString().padStart(4,'0');
        const ps   = r.poststed || r.sted || '';

        let lat = parseFloat(r.lat || r.latitude);
        let lon = parseFloat(r.lon || r.lng || r.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) { points.push({lat, lon, navn, adr, pn, ps}); continue; }

        const x = parseFloat(r.x3035 || r.x);
        const y = parseFloat(r.y3035 || r.y);
        if (Number.isFinite(x) && Number.isFinite(y)) {
          const [lonW, latW] = proj4('EPSG:3035','WGS84',[x,y]);
          points.push({lat: latW, lon: lonW, navn, adr, pn, ps});
          continue;
        }
        toGeocode++;
        points.push({lat: null, lon: null, navn, adr, pn, ps});
      }

      if(toGeocode){
        if(butikker2Status) butikker2Status.textContent = `Geokoder ${toGeocode} adresser …`;
        for(const p of points){
          if(p.lat != null && p.lon != null) continue;
          const query = [p.adr, p.pn, p.ps, 'Norge'].filter(Boolean).join(', ');
          const res = await geocodeAdresse(query);
          if(res){ p.lat = res.lat; p.lon = res.lon; }
          doneGeocode++;
          if(butikker2Status && doneGeocode % 1 === 0){ butikker2Status.textContent = `Geokoder ${doneGeocode}/${toGeocode} …`; }
          await sleep(300);
        }
        if(butikker2Status) butikker2Status.textContent = '';
      }

      let added = 0;
      points.forEach(p => {
        if(!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return;
        const m = L.circleMarker([p.lat, p.lon], {radius: 6, weight: 1, color: butikk2Farge, fillOpacity: 0.85});
        const adrTxt = [p.adr, p.pn, p.ps].filter(Boolean).join(', ');
        m.bindPopup(`<strong>${p.navn || 'Butikk'}</strong><br>${adrTxt}`);
        butikkLayer.addLayer(m);
        added++;
      });

      const cb = document.getElementById('toggleButikk2');
      if(cb?.checked) map.addLayer(butikkLayer);
      oppdaterButikkTellere();
      if(added){ try { map.fitBounds(butikkLayer.getBounds().pad(0.05)); } catch {} }  <!-- BUGFIX: bruk butikkLayer -->

    } catch(err){
      console.warn('Feil ved lasting av butikker2:', err);
      const butikker2Status = document.getElementById('butikker2-status');
      if(butikker2Status) butikker2Status.textContent = '';
    }
  }

  // Login/passord for navnesøk
  document.getElementById('loginBtn').addEventListener('click', () => {
    const pw = document.getElementById('passwordInput').value;
    if(pw === riktigPassord){
      kanSokeNavn = true;
      document.getElementById('loginStatus').innerText = "Navnesøk aktivert";
      document.getElementById('passwordInput').value = '';
      enrichAll();
      oppdaterFilterTellinger();
    } else {
      kanSokeNavn = false;
      document.getElementById('loginStatus').innerText = "Feil passord";
    }
  });
</script>
</body>
</html>
